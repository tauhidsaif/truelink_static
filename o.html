<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Opening…</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial;display:flex;align-items:center;justify-content:center;height:100vh;margin:0;background:linear-gradient(135deg,#f0f4f8,#e2e8f0)}
    .card{background:white;padding:20px;border-radius:12px;max-width:460px;width:94%;text-align:center;box-shadow:0 8px 30px rgba(0,0,0,0.08)}
    .spinner{width:48px;height:48px;border:4px solid rgba(0,0,0,0.08);border-top-color:#111;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 12px}
    @keyframes spin{to{transform:rotate(360deg)}}
    a{display:inline-block;margin-top:8px;padding:8px 14px;background:#111;color:#fff;border-radius:8px;text-decoration:none}
    @media (max-width:420px){ .card{padding:16px} .spinner{width:40px;height:40px} }
    /* keep fallback link from overflowing on tiny screens */
    .card a { max-width:100%; overflow-wrap:anywhere; display:inline-block; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/lz-string/libs/lz-string.min.js"></script>
</head>
<body>
  <div class="card" role="main" aria-live="polite">
    <div class="spinner" aria-hidden></div>
    <h2 id="title" style="margin:0 0 8px">Opening the app…</h2>
    <p id="desc" style="color:#666;margin-top:0">If nothing happens, the link will open in your browser.</p>
    <div id="fallback" style="margin-top:14px"></div>
  </div>

<script>
// Robust payload decoder: prefers LZ-String, falls back to base64/url-decode
function decodeHashPayload() {
  const hash = location.hash ? location.hash.slice(1) : null;
  if (!hash) return null;
  // Try LZ-String first
  try {
    if (typeof LZString !== "undefined" && LZString.decompressFromEncodedURIComponent) {
      const dec = LZString.decompressFromEncodedURIComponent(hash);
      if (dec) return JSON.parse(dec);
    }
  } catch (e) {
    console.warn("LZ decompress error:", e);
  }
  // fallback: try decodeURIComponent + atob
  try {
    // attempt URL-decoded base64
    const s = decodeURIComponent(hash.replace(/-/g,'+').replace(/_/g,'/'));
    try {
      const json = atob(s);
      return JSON.parse(json);
    } catch (e) { /* continue */ }
    // try direct atob
    try {
      const json2 = atob(hash);
      return JSON.parse(json2);
    } catch (e) { /* give up */ }
  } catch (e) { /* ignore */ }
  return null;
}

// parse mailto using URL when possible; safe guard
function parseMailto(urlStr){
  try{
    // For mailto, some browsers require a base; but URL works in modern browsers for mailto.
    const u = new URL(urlStr);
    const to = decodeURIComponent(u.pathname||"").trim();
    const p = u.searchParams;
    return {
      to,
      subject: p.get("subject") || p.get("su") || "",
      body: p.get("body") || "",
      cc: p.get("cc") || "",
      bcc: p.get("bcc") || ""
    };
  } catch (e) {
    // fallback simple parse
    try {
      const parts = urlStr.split("?");
      const to = parts[0].replace(/^mailto:/i, "");
      const p = new URLSearchParams(parts[1] || "");
      return {
        to: decodeURIComponent(to || ""),
        subject: p.get("subject") || p.get("su") || "",
        body: p.get("body") || "",
        cc: p.get("cc") || "",
        bcc: p.get("bcc") || ""
      };
    } catch (e2) {
      return {};
    }
  }
}

// detectApp and buildDeepLink guard against malformed input
function detectApp(urlStr) {
  try {
    const u = new URL(urlStr);
    if (u.protocol === "mailto:") return { app: "gmail", meta: { kind: "mailto", fields: parseMailto(urlStr) } };
    const host = (u.hostname || "").replace(/^www\./, "");
    if (host.includes("youtube.com") || host === "youtu.be") return { app: "youtube", meta: { u } };
    if (host === "wa.me" || host.includes("whatsapp.com")) return { app: "whatsapp", meta: { u } };
    if (host === "t.me" || host.includes("telegram.me") || host.includes("telegram.org")) return { app: "telegram", meta: { u } };
    if (host.includes("instagram.com")) return { app: "instagram", meta: { u } };
    if (host.startsWith("amazon.") || host.includes("amazon.")) return { app: "amazon", meta: { u } };
    if (host.includes("twitter.com") || host.includes("x.com")) return { app: "twitter", meta: { u } };
    if (host.includes("facebook.com")) return { app: "facebook", meta: { u } };
    return { app: null, meta: { u } };
  } catch (e) {
    return { app: null, meta: {} };
  }
}

function buildChromeScheme(fallbackHttps){ return `googlechrome://${fallbackHttps.replace(/^https?:\/\//, "")}`; }

function buildDeepLink(urlStr){
  try {
    const { app, meta } = detectApp(urlStr);
    const u = (meta && meta.u) ? meta.u : new URL(urlStr);
    const fallbackHttps = urlStr;
    const chromeScheme = buildChromeScheme(fallbackHttps);
    let ios=null, androidIntent=null;
    const encFB = encodeURIComponent(fallbackHttps);
    const asHostPath = (urlObj) => `${urlObj.hostname}${urlObj.pathname}${urlObj.search}${urlObj.hash || ""}`;

    switch(app){
      case "youtube": {
        let vId = u.searchParams.get("v");
        if (!vId && u.hostname === "youtu.be") vId = u.pathname.slice(1);
        ios = vId ? `youtube://watch?v=${vId}` : `youtube://`;
        const hostPath = vId ? `www.youtube.com/watch?v=${encodeURIComponent(vId)}` : asHostPath(new URL("https://www.youtube.com"));
        androidIntent = `intent://${hostPath}#Intent;scheme=https;package=com.google.android.youtube;S.browser_fallback_url=${encFB};end`;
        break;
      }
      case "whatsapp": {
        const pathDigits = (u && u.pathname) ? u.pathname.replace(/^\/send\/?/, "").replace(/\//g,"") : "";
        const phone = (u && u.searchParams) ? u.searchParams.get("phone") || (/^\d{6,15}$/.test(pathDigits) ? pathDigits : "") : "";
        const text = (u && u.searchParams) ? u.searchParams.get("text") || "" : "";
        const qp = new URLSearchParams();
        if (phone) qp.set("phone", phone);
        if (text) qp.set("text", text);
        const q = qp.toString();
        ios = q ? `whatsapp://send?${q}` : `whatsapp://send`;
        androidIntent = `intent://send${q ? `?${q}` : ""}#Intent;scheme=whatsapp;package=com.whatsapp;S.browser_fallback_url=${encFB};end`;
        break;
      }
      case "telegram": {
        const path = u.pathname ? u.pathname.replace(/^\//, "") : "";
        const userMatch = path.match(/^([A-Za-z0-9_]{5,32})$/);
        if (userMatch) ios = `tg://resolve?domain=${userMatch[1]}`;
        const hostPath = asHostPath(u);
        androidIntent = `intent://${hostPath}#Intent;scheme=https;package=org.telegram.messenger;S.browser_fallback_url=${encFB};end`;
        break;
      }
      case "instagram": {
        const parts = u.pathname ? u.pathname.split("/").filter(Boolean) : [];
        if (parts[0] && parts[0] !== "p") ios = `instagram://user?username=${encodeURIComponent(parts[0])}`;
        else ios = `instagram://`;
        const hostPath = asHostPath(u);
        androidIntent = `intent://${hostPath}#Intent;scheme=https;package=com.instagram.android;S.browser_fallback_url=${encFB};end`;
        break;
      }
      case "amazon": {
        ios = `amazon://`;
        const hostPath = asHostPath(u);
        androidIntent = `intent://${hostPath}#Intent;scheme=https;package=com.amazon.mShop.android.shopping;S.browser_fallback_url=${encFB};end`;
        break;
      }
      case "twitter": {
        let iosScheme = `twitter://`;
        const statusIdMatch = u.pathname ? u.pathname.match(/\/status\/(\d+)/) : null;
        if (statusIdMatch) iosScheme = `twitter://status?id=${statusIdMatch[1]}`;
        ios = iosScheme;
        const hostPath = asHostPath(u);
        androidIntent = `intent://${hostPath}#Intent;scheme=https;package=com.twitter.android;S.browser_fallback_url=${encFB};end`;
        break;
      }
      case "facebook": {
        ios = `fb://`;
        const hostPath = asHostPath(u);
        androidIntent = `intent://${hostPath}#Intent;scheme=https;package=com.facebook.katana;S.browser_fallback_url=${encFB};end`;
        break;
      }
      case "gmail": {
        const m = (meta && meta.fields) || {};
        const qp = new URLSearchParams();
        if (m.to) qp.set("to", m.to);
        if (m.subject) qp.set("subject", m.subject);
        if (m.body) qp.set("body", m.body);
        if (m.cc) qp.set("cc", m.cc);
        if (m.bcc) qp.set("bcc", m.bcc);
        ios = `googlegmail:///co?${qp.toString()}`;
        const gmailWeb = new URL("https://mail.google.com/mail/");
        gmailWeb.searchParams.set("view","cm"); gmailWeb.searchParams.set("fs","1");
        if (m.to) gmailWeb.searchParams.set("to", m.to);
        if (m.subject) gmailWeb.searchParams.set("su", m.subject);
        if (m.body) gmailWeb.searchParams.set("body", m.body);
        if (m.cc) gmailWeb.searchParams.set("cc", m.cc);
        if (m.bcc) gmailWeb.searchParams.set("bcc", m.bcc);
        const gmailWebStr = gmailWeb.toString();
        const q = new URLSearchParams();
        if (m.to) q.set("to", m.to);
        if (m.subject) q.set("subject", m.subject);
        if (m.body) q.set("body", m.body);
        if (m.cc) q.set("cc", m.cc);
        if (m.bcc) q.set("bcc", m.bcc);
        androidIntent = `intent://compose?${q.toString()}#Intent;scheme=mailto;package=com.google.android.gm;S.browser_fallback_url=${encodeURIComponent(gmailWebStr)};end`;
        return { ios, androidIntent, fallbackHttps: gmailWebStr, chromeScheme: buildChromeScheme(gmailWebStr) };
      }
      default: {
        const hostPath = asHostPath(u);
        androidIntent = `intent://${hostPath}#Intent;scheme=${u.protocol ? u.protocol.replace(":", "") : "https"};S.browser_fallback_url=${encFB};end`;
        ios = null;
      }
    }
    return { ios, androidIntent, fallbackHttps, chromeScheme };
  } catch (e) {
    return { ios: null, androidIntent: null, fallbackHttps: urlStr, chromeScheme: buildChromeScheme(urlStr) };
  }
}

// main redirect
(function(){
  const payload = decodeHashPayload();
  if (!payload || !payload.u) {
    document.getElementById('title').textContent = "Invalid link";
    document.getElementById('desc').textContent = "This link is malformed or missing data.";
    return;
  }

  const url = payload.u;
  const { ios, androidIntent, fallbackHttps, chromeScheme } = buildDeepLink(url);

  const fallbackEl = document.getElementById('fallback');
  const anchor = document.createElement('a');
  anchor.href = fallbackHttps;
  anchor.target = "_blank";
  anchor.rel = "noopener noreferrer";
  anchor.textContent = "Open in browser";
  fallbackEl.appendChild(anchor);

  const ua = navigator.userAgent || navigator.vendor || window.opera;
  const isAndroid = /android/i.test(ua);
  const isIOS = /iPhone|iPad|iPod/i.test(ua);

  function go(h) { try { if (h) location.href = h; } catch(e) { console.warn("redirect failed", e); } }

  if (isAndroid) {
    if (androidIntent) go(androidIntent);
    setTimeout(() => { go(fallbackHttps); }, 1200);
  } else if (isIOS) {
    let triedScheme = false;
    if (ios) { triedScheme = true; go(ios); }
    setTimeout(() => {
      go(chromeScheme);
      setTimeout(() => { go(fallbackHttps); }, 900);
    }, triedScheme ? 700 : 0);
  } else {
    go(fallbackHttps);
  }
})();
</script>
</body>
</html>
